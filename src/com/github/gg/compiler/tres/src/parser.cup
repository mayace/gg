package com.github.gg.compiler.tres;

import com.github.gg.Dict;
import com.github.gg.Node;
import com.github.gg.TOperation;
import com.github.gg.TType;
import com.github.gg.TErr;
import com.github.gg.Err;
import java.util.ArrayList;

//===============================================================================================//
//===============================================================================================//

parser code {:
	Object info = null;

	public void report_error(String message, Object info){
		this.info = info;
    }

    public void report_fatal_error(String message,Object info){
        report_error(message,info);
        Err err = new Err(TErr.SINTACTICO,message,info);
        System.err.println(err);
    }
:};

action code{::}
   
//===============================================================================================//
//===============================================================================================//
terminal        String 		ID,INT,PCOMA,DPUNTOS,EQUAL,DEQUAL,LTHAN,LETHAN,BTHAN,BETHAN,NEQUAL,
							PLUS,MINUS,MULT,DIV,LP,RP,GOTO,IF,LS,RS,PRINT,LL,RL,KW_CALL,
							PRINTLN,HEAP,STACK,H,P,COMMENT,ERROR,MOD,EXP,FLOAT,KW_VOID,
							KW_LINEA,KW_TEXTO,KW_ARCO,KW_RECTANGULO,KW_OVALO,KW_POLIGONO,KW_LIENZO
							;
non terminal    Dict        app,stmt,stmt_list,label,expr_assign,id,int,expr_arith,expr_rel,
							expr_primary,stmt_goto,stmt_if,method_stmts_list,
							err, error_lexico,error_sintactico,float,memory,heap,stack,p,h,
							comment,method,method_stmts,method_stmt,method_stmt_list,method_call
							;
//===============================================================================================//
//===============================================================================================//

app			::=	stmt_list:l 	{:RESULT = new Dict("stmts",l);:}
				| 				{:RESULT = new Dict("stmts",new Dict("list",new ArrayList<>()));:}
				;
stmt_list	::=	stmt_list:l stmt:x
				{:
					l.getDictArrayList("list").add(x);
					RESULT = l;
				:}
				|stmt:x 			
				{:
					RESULT = new Dict("list",new ArrayList<Dict>(){{add(x);}});
				:}
				;

stmt 		::=	method:x 	{:RESULT = x;:}
				|comment:x 	{:RESULT = x;:}
				|err:x		{:RESULT = x;:}
				;

method 		::= KW_VOID id:x LP RP LL method_stmts_list:ss RL
				{:
					Dict ref = new Dict("name",x,"stmts",ss,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-6));
					RESULT = new Dict("nodo",new Node(TOperation.DEF_METHOD,null,null,ref));
				:}
				;

method_stmts_list 	::=	method_stmts_list id DPUNTOS method_stmts
						|method_stmts
						// |label method_stmts
						;

method_stmts 	::=	method_stmt_list:x 	{:RESULT = x;:}
					| 					{:RESULT = new Dict("list",new ArrayList<>());:}
					;

method_stmt_list 	::=	method_stmt_list:l method_stmt:x
						{:
							l.getDictArrayList("list").add(x);
							RESULT = l;
						:}
						|method_stmt:x
						{:
							RESULT = new Dict("list",new ArrayList<Dict>(){{add(x);}});
						:}
						;

method_stmt 	::=	expr_assign:x PCOMA 	{:RESULT = x;:}
					|stmt_goto:x PCOMA		{:RESULT = x;:}
					|method_call:x PCOMA 	{:RESULT = x;:}
					|stmt_if:x 				{:RESULT = x;:}
					|err:x 					{:RESULT = x;:}
					|comment:x 				{:RESULT = x;:}
					;

label	::=	id:x DPUNTOS 	
				{:
					Dict ref = new Dict("name",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-0));
					RESULT = new Dict("nodo",new Node(TOperation.LABEL,null,null,ref));
				:}
				;

stmt_goto 	::=	GOTO id:x
				{:
					Dict ref = new Dict("name",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict(TOperation.GOTO,null,null,ref);
				:}
				;

stmt_if 	::=	IF LP expr_rel:x RP  stmt_goto:g PCOMA
				{:
					Dict ref = new Dict("condition",x,"goto",g,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-4));
					RESULT = new Dict(TOperation.STMT_IF,null,null,ref);
				:}
				;


expr_assign ::=	id:x EQUAL expr_arith:v
				{:
					Dict ref = new Dict("name",x,"val",v,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.SET_VAR,x.getNode("nodo"),v.getNode("nodo"),ref));
				:} 
				|memory:x EQUAL expr_arith:v
				{:
					Dict ref = new Dict("name",x,"val",v,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.SET_VAR,x.getNode("nodo"),v.getNode("nodo"),ref));
				:}
				;

expr_rel 	::=	expr_primary:l BTHAN expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.BTHAN,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l LTHAN expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.LTHAN,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l BETHAN expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.BETHAN,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l LETHAN expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.LETHAN,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l DEQUAL expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.DEQUAL,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l NEQUAL expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.NEQUAL,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				;

expr_arith 	::=	expr_primary:l PLUS expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.PLUS,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l MINUS expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.MINUS,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l MULT expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.MULT,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l DIV expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.DIV,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l MOD expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.MOD,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l EXP expr_primary:r
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.elementAt(CUP$Parser$top-1));
					RESULT = new Dict("nodo",new Node(TOperation.EXP,l.getNode("nodo"),r.getNode("nodo"),ref));
				:}
				|expr_primary:l
				{:
					RESULT = l;
				:}
				;


expr_primary	::=	id:x  			{:RESULT = x;:}
					|memory:x 		{:RESULT = x;:}
					|p:x 			{:RESULT = x;:}
					|h:x 			{:RESULT = x;:}
					|int:x 			{:RESULT = x;:}
					|float:x 		{:RESULT = x;:}
					;

method_call 	::=	KW_CALL id:x RP LP
					{:
						RESULT = new Dict("nodo",new Node(TOperation.METHOD_CALL,null,null,new Dict("name",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3))));
					:}
					|KW_CALL PRINT:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.PRINT,null,null,ref));
	  				:}
					|KW_CALL PRINTLN:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.PRINTLN,null,null,ref));
	  				:}
					|KW_CALL KW_LINEA:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.NM_LINEA,null,null,ref));
	  				:}
					|KW_CALL KW_TEXTO:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.NM_TEXTO,null,null,ref));
	  				:}
					|KW_CALL KW_ARCO:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.NM_ARCO,null,null,ref));
	  				:}
					|KW_CALL KW_RECTANGULO:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.NM_RECTANGULO,null,null,ref));
	  				:}
					|KW_CALL KW_OVALO:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.NM_OVALO,null,null,ref));
	  				:}
					|KW_CALL KW_POLIGONO:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.NM_POLIGONO,null,null,ref));
	  				:}
					|KW_CALL KW_LIENZO:x RP LP
					{:
	  					Dict ref = new Dict("name",new Dict("val",x,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-2)),"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3));
	  					RESULT = new Dict("nodo",new Node(TOperation.NM_LIENZO,null,null,ref));
	  				:}
					;
p 			::=	P:x
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.peek(),"type","pointer","val",x);
					RESULT = new Dict("nodo",new Node(TOperation.LEAF,null,null,ref));
				:}
				;
h 			::= H:x
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.peek(),"type","pointer","val",x);
					RESULT = new Dict("nodo",new Node(TOperation.LEAF,null,null,ref));
				:}
				;

memory 		::=	stack:x 	{:RESULT = x;:}
				|heap:x 	{:RESULT = x;:}
				;
stack 		::=	STACK:m LS id:x RS
				{:
					Dict ref = new Dict("memory",Sym.STACK,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3),"position",x,"type","memory");
					RESULT = new Dict("nodo",new Node(TOperation.LEAF,null,null,ref));
				:}
				;
heap 		::= HEAP:m LS id:x RS
				{:
					Dict ref = new Dict("memory",Sym.HEAPB ,"info",CUP$Parser$stack.elementAt(CUP$Parser$top-3),"position",x,"type","memory");
					RESULT = new Dict("nodo",new Node(TOperation.LEAF,null,null,ref));
				:}
				;

id 			::= ID:x
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.peek(),"type",TType.REF,"val",x);
					RESULT = new Dict("nodo",new Node(TOperation.LEAF,null,null,ref));
				:}
				;
int 		::=	INT:x
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.peek(),"type",TType.INT,"val",x);
					RESULT = new Dict("nodo",new Node(TOperation.LEAF,null,null,ref));
				:}
				;
float 		::=	FLOAT:x
				{:
					Dict ref = new Dict("info",CUP$Parser$stack.peek(),"type",TType.FLOAT,"val",x);
					RESULT = new Dict("nodo",new Node(TOperation.LEAF,null,null,ref));
				:}
				;


error_lexico	::=	ERROR:x
					{:
						Dict ref = new Dict("info",parser.info,"val",x);
						RESULT = new Dict("nodo",new Node(TOperation.ERROR_LEXICO,null,null,ref));
					:}
					;

error_sintactico 	::=	error:x
						{:
							Dict ref = new Dict("info",parser.info,"val",x);
							RESULT = new Dict("nodo",new Node(TOperation.ERROR_SINTACTICO,null,null,ref));
						:}
						;


err 	::=	error_sintactico:x 	{:RESULT = x;:}
			|error_lexico:x 	{:RESULT = x;:}
			;

comment 	::=	COMMENT:x
				{:
					RESULT = new Dict("nodo",new Node(TOperation.COMMENT,null,null,new Dict("val",x,"info",CUP$Parser$stack.peek())));
				:}
				;